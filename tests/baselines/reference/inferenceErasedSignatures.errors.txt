tests/cases/compiler/inferenceErasedSignatures.ts(14,11): error TS2416: Property 'baz' in type 'SomeClass' is not assignable to the same property in base type 'SomeAbstractClass<number, string, boolean>'.
  Type '(context: number) => Promise<string>' is not assignable to type '(c: number) => Promise<string>'.
    The 'this' types of each signature are incompatible.
      Type 'SomeAbstractClass<C, M, R>' is not assignable to type 'SomeClass'.
        Types of property 'baz' are incompatible.
          Type '(c: C) => Promise<M>' is not assignable to type '(context: number) => Promise<string>'.
            The 'this' types of each signature are incompatible.
              Type 'SomeClass' is not assignable to type 'SomeAbstractClass<C, M, R>'.
                Types of property 'foo' are incompatible.
                  Type '(r?: boolean | undefined) => void' is not assignable to type '(r?: R | undefined) => void'.
                    Types of parameters 'r' and 'r' are incompatible.
                      Type 'R | undefined' is not assignable to type 'boolean | undefined'.
                        Type 'R' is not assignable to type 'boolean | undefined'.
                          Type 'R' is not assignable to type 'true'.


==== tests/cases/compiler/inferenceErasedSignatures.ts (1 errors) ====
    // Repro from #37163
    
    declare class SomeBaseClass {
        set<K extends keyof this>(key: K, value: this[K]): this[K];
    }
    
    abstract class SomeAbstractClass<C, M, R> extends SomeBaseClass {
        foo!: (r?: R) => void;
        bar!: (r?: any) => void;
        abstract baz(c: C): Promise<M>;
    }
    
    class SomeClass extends SomeAbstractClass<number, string, boolean> {
        async baz(context: number): Promise<string> {
              ~~~
!!! error TS2416: Property 'baz' in type 'SomeClass' is not assignable to the same property in base type 'SomeAbstractClass<number, string, boolean>'.
!!! error TS2416:   Type '(context: number) => Promise<string>' is not assignable to type '(c: number) => Promise<string>'.
!!! error TS2416:     The 'this' types of each signature are incompatible.
!!! error TS2416:       Type 'SomeAbstractClass<C, M, R>' is not assignable to type 'SomeClass'.
!!! error TS2416:         Types of property 'baz' are incompatible.
!!! error TS2416:           Type '(c: C) => Promise<M>' is not assignable to type '(context: number) => Promise<string>'.
!!! error TS2416:             The 'this' types of each signature are incompatible.
!!! error TS2416:               Type 'SomeClass' is not assignable to type 'SomeAbstractClass<C, M, R>'.
!!! error TS2416:                 Types of property 'foo' are incompatible.
!!! error TS2416:                   Type '(r?: boolean | undefined) => void' is not assignable to type '(r?: R | undefined) => void'.
!!! error TS2416:                     Types of parameters 'r' and 'r' are incompatible.
!!! error TS2416:                       Type 'R | undefined' is not assignable to type 'boolean | undefined'.
!!! error TS2416:                         Type 'R' is not assignable to type 'boolean | undefined'.
!!! error TS2416:                           Type 'R' is not assignable to type 'true'.
            return `${context}`;
        }
    }
    
    type CType<T> = T extends SomeAbstractClass<infer C, any, any> ? C : never;
    type MType<T> = T extends SomeAbstractClass<any, infer M, any> ? M : never;
    type RType<T> = T extends SomeAbstractClass<any, any, infer R> ? R : never;
    
    type SomeClassC = CType<SomeClass>; // number
    type SomeClassM = MType<SomeClass>; // string
    type SomeClassR = RType<SomeClass>; // boolean
    
    // Repro from #37163
    
    interface BaseType<T1, T2>  {
        set<K extends keyof this>(key: K, value: this[K]): this[K];
        useT1(c: T1): void;
        useT2(r?: T2): void;
        unrelatedButSomehowRelevant(r?: any): void;
    }
    
    interface InheritedType extends BaseType<number, boolean> {
        // This declaration shouldn't do anything...
        useT1(_: number): void
    }
    
    // Structural expansion of InheritedType
    interface StructuralVersion  {
        set<K extends keyof this>(key: K, value: this[K]): this[K];
        useT1(c: number): void;
        useT2(r?: boolean): void;
        unrelatedButSomehowRelevant(r?: any): void;
    }
    
    type GetT1<T> = T extends BaseType<infer U, any> ? U : never;
    
    type T1 = GetT1<InheritedType>; // number
    type T2 = GetT1<StructuralVersion>; // number
    