tests/cases/conformance/classes/members/privateNames/privateNamesAndStaticFields.ts(6,11): error TS18013: Property '#foo' is not accessible outside class 'B' because it has a private identifier.
tests/cases/conformance/classes/members/privateNames/privateNamesAndStaticFields.ts(7,11): error TS2339: Property '#bar' does not exist on type 'typeof B'.
tests/cases/conformance/classes/members/privateNames/privateNamesAndStaticFields.ts(14,9): error TS2684: The 'this' context of type 'void' is not assignable to method's 'this' of type 'A'.


==== tests/cases/conformance/classes/members/privateNames/privateNamesAndStaticFields.ts (3 errors) ====
    class A {
        static #foo: number;
        static #bar: number;
        constructor () {
            A.#foo = 3;
            B.#foo; // Error
              ~~~~
!!! error TS18013: Property '#foo' is not accessible outside class 'B' because it has a private identifier.
            B.#bar; // Error
              ~~~~
!!! error TS2339: Property '#bar' does not exist on type 'typeof B'.
        }
    }
    
    class B extends A {
        static #foo: string;
        constructor () {
            super();
            ~~~~~~~
!!! error TS2684: The 'this' context of type 'void' is not assignable to method's 'this' of type 'A'.
            B.#foo = "some string";
        }
    }
    
    // We currently filter out static private identifier fields in `getUnmatchedProperties`.
    // We will need a more robust solution when we support static fields
    const willErrorSomeDay: typeof A = class {}; // OK for now
    