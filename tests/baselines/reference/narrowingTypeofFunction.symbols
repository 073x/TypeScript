=== tests/cases/compiler/narrowingTypeofFunction.ts ===
type Meta = { foo: string }
>Meta : Symbol(Meta, Decl(narrowingTypeofFunction.ts, 0, 0))
>foo : Symbol(foo, Decl(narrowingTypeofFunction.ts, 0, 13))

interface F { (): string }
>F : Symbol(F, Decl(narrowingTypeofFunction.ts, 0, 27))

const x = (a: (F & Meta) | string) => {
>x : Symbol(x, Decl(narrowingTypeofFunction.ts, 3, 5))
>a : Symbol(a, Decl(narrowingTypeofFunction.ts, 3, 11))
>F : Symbol(F, Decl(narrowingTypeofFunction.ts, 0, 27))
>Meta : Symbol(Meta, Decl(narrowingTypeofFunction.ts, 0, 0))

    if (typeof a === "function") {
>a : Symbol(a, Decl(narrowingTypeofFunction.ts, 3, 11))

        // ts.version >= 4.3.5: never -- unexpected
        // ts.version <= 4.2.3: F & Meta -- expected
        a;
>a : Symbol(a, Decl(narrowingTypeofFunction.ts, 3, 11))
    }
    else {
        a;
>a : Symbol(a, Decl(narrowingTypeofFunction.ts, 3, 11))
    }
}
